<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnimHost: Ort::detail::ValueImpl&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AnimHost<span id="projectnumber">&#160;0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_ort.html">Ort</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">ValueImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="struct_ort_1_1detail_1_1_value_impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ort::detail::ValueImpl&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Ort::detail::ValueImpl&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl__inherit__graph.png" border="0" usemap="#a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_inherit__map" id="a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="22,155,197,181"/>
<area shape="rect" href="struct_ort_1_1detail_1_1_const_value_impl.html" title=" " alt="" coords="5,80,214,107"/>
<area shape="poly" title=" " alt="" coords="112,122,112,154,107,154,107,122"/>
<area shape="rect" href="struct_ort_1_1detail_1_1_base.html" title="Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction ..." alt="" coords="36,5,183,32"/>
<area shape="poly" title=" " alt="" coords="112,48,112,80,107,80,107,48"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Ort::detail::ValueImpl&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl__coll__graph.png" border="0" usemap="#a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_coll__map" id="a_ort_1_1detail_1_1_value_impl_3_01_t_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="22,155,197,181"/>
<area shape="rect" href="struct_ort_1_1detail_1_1_const_value_impl.html" title=" " alt="" coords="5,80,214,107"/>
<area shape="poly" title=" " alt="" coords="112,122,112,154,107,154,107,122"/>
<area shape="rect" href="struct_ort_1_1detail_1_1_base.html" title="Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction ..." alt="" coords="36,5,183,32"/>
<area shape="poly" title=" " alt="" coords="112,48,112,80,107,80,107,48"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa56bd5e28c57ca24311ce48792326d6e" id="r_aa56bd5e28c57ca24311ce48792326d6e"><td class="memItemLeft" align="right" valign="top"><a id="aa56bd5e28c57ca24311ce48792326d6e" name="aa56bd5e28c57ca24311ce48792326d6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>B</b> = <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">ConstValueImpl</a>&lt;T&gt;</td></tr>
<tr class="separator:aa56bd5e28c57ca24311ce48792326d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905" id="r_ab80f19abb74be8f5a489ae95eaa13905"><td class="memItemLeft" align="right" valign="top"><a id="ab80f19abb74be8f5a489ae95eaa13905" name="ab80f19abb74be8f5a489ae95eaa13905"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>B</b></td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl" id="r_ab80f19abb74be8f5a489ae95eaa13905"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>B</b> = <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt;T&gt;</td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base" id="r_adac6328b9d9b37cddd94f6b21bebee74"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>contained_type</b> = T</td></tr>
<tr class="separator:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28317ae875d9c8b35f0cbed64f776c5a" id="r_a28317ae875d9c8b35f0cbed64f776c5a"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a28317ae875d9c8b35f0cbed64f776c5a"><td class="memTemplItemLeft" align="right" valign="top">R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28317ae875d9c8b35f0cbed64f776c5a">GetTensorMutableData</a> ()</td></tr>
<tr class="memdesc:a28317ae875d9c8b35f0cbed64f776c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const typed pointer to an OrtValue/Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:a28317ae875d9c8b35f0cbed64f776c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b55de64b5457b5fd0538ec8225a0507" id="r_a8b55de64b5457b5fd0538ec8225a0507"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b55de64b5457b5fd0538ec8225a0507">GetTensorMutableRawData</a> ()</td></tr>
<tr class="memdesc:a8b55de64b5457b5fd0538ec8225a0507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed non-const pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a8b55de64b5457b5fd0538ec8225a0507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fe9ca6bd6e2dc09c0beb95ee3e1eb" id="r_a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memTemplItemLeft" align="right" valign="top">R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a657fe9ca6bd6e2dc09c0beb95ee3e1eb">At</a> (const std::vector&lt; int64_t &gt; &amp;location)</td></tr>
<tr class="separator:a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98717a93e02f4b91ebabaf3c4ab891c" id="r_ac98717a93e02f4b91ebabaf3c4ab891c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98717a93e02f4b91ebabaf3c4ab891c">FillStringTensor</a> (const char *const *s, size_t s_len)</td></tr>
<tr class="memdesc:ac98717a93e02f4b91ebabaf3c4ab891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all strings at once in a string tensor.  <br /></td></tr>
<tr class="separator:ac98717a93e02f4b91ebabaf3c4ab891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a59534f82ccf9ff55b8a692270e4503" id="r_a0a59534f82ccf9ff55b8a692270e4503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a59534f82ccf9ff55b8a692270e4503">FillStringTensorElement</a> (const char *s, size_t index)</td></tr>
<tr class="memdesc:a0a59534f82ccf9ff55b8a692270e4503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single string in a string tensor.  <br /></td></tr>
<tr class="separator:a0a59534f82ccf9ff55b8a692270e4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde85d0a4ef2f1a38ff369d218ec56c" id="r_afbde85d0a4ef2f1a38ff369d218ec56c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbde85d0a4ef2f1a38ff369d218ec56c">GetResizedStringTensorElementBuffer</a> (size_t index, size_t buffer_length)</td></tr>
<tr class="memdesc:afbde85d0a4ef2f1a38ff369d218ec56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate if necessary and obtain a pointer to a UTF-8 encoded string element buffer indexed by the flat element index, of the specified length.  <br /></td></tr>
<tr class="separator:afbde85d0a4ef2f1a38ff369d218ec56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80e2a725f45cdeceb06bcba643e978" id="r_a8b80e2a725f45cdeceb06bcba643e978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b80e2a725f45cdeceb06bcba643e978">UseCooIndices</a> (int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:a8b80e2a725f45cdeceb06bcba643e978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a8b80e2a725f45cdeceb06bcba643e978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc53699ae881046ccf26527fb0e0d7d2" id="r_adc53699ae881046ccf26527fb0e0d7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc53699ae881046ccf26527fb0e0d7d2">UseCsrIndices</a> (int64_t *inner_data, size_t inner_num, int64_t *outer_data, size_t outer_num)</td></tr>
<tr class="memdesc:adc53699ae881046ccf26527fb0e0d7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:adc53699ae881046ccf26527fb0e0d7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ba9e6d44e6a1141c04d1fefaa3b6c6" id="r_a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ba9e6d44e6a1141c04d1fefaa3b6c6">UseBlockSparseIndices</a> (const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, int32_t *indices_data)</td></tr>
<tr class="memdesc:a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30c08c17ce26d0c89e8c7dea62f9a75" id="r_ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab30c08c17ce26d0c89e8c7dea62f9a75">FillSparseTensorCoo</a> (const OrtMemoryInfo *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values_param, const int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67cc830bdf35e40717b06ca70b22ead" id="r_af67cc830bdf35e40717b06ca70b22ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af67cc830bdf35e40717b06ca70b22ead">FillSparseTensorCsr</a> (const OrtMemoryInfo *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const int64_t *inner_indices_data, size_t inner_indices_num, const int64_t *outer_indices_data, size_t outer_indices_num)</td></tr>
<tr class="memdesc:af67cc830bdf35e40717b06ca70b22ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:af67cc830bdf35e40717b06ca70b22ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57d606a608abda7df7b9b23a301a3e" id="r_a7a57d606a608abda7df7b9b23a301a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a57d606a608abda7df7b9b23a301a3e">FillSparseTensorBlockSparse</a> (const OrtMemoryInfo *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, const int32_t *indices_data)</td></tr>
<tr class="memdesc:a7a57d606a608abda7df7b9b23a301a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:a7a57d606a608abda7df7b9b23a301a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_ab541b268a2aad607ceec3a3da7be8ba0"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab541b268a2aad607ceec3a3da7be8ba0">GetOpaqueData</a> (const char *domain, const char *type_name, R &amp;) const</td></tr>
<tr class="memdesc:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to a user defined data for experimental purposes.  <br /></td></tr>
<tr class="separator:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a64c428d4e7a1134f806fcf7b15dc35e7"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTensor</b> () const</td></tr>
<tr class="memdesc:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around ::OrtValue.">Value</a> is a tensor, false for other types like map/sequence/etc. <br /></td></tr>
<tr class="separator:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_aa2656357fbdb63bcaa3b319191e4e37a"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasValue</b> () const</td></tr>
<tr class="separator:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_ab0589e1f752d7b18a850699be24c8c84"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetCount</b> () const</td></tr>
<tr class="memdesc:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Return true if OrtValue contains data and returns false if the OrtValue is a None <br /></td></tr>
<tr class="separator:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_aafc98d55540fa407b10b06ee4e6a2849"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetValue</b> (int index, <a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator) const</td></tr>
<tr class="separator:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a2700d2f2a5d9a7922c81419cc9fed664"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664">GetStringTensorDataLength</a> () const</td></tr>
<tr class="memdesc:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful for allocating necessary memory and calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656" title="The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into...">GetStringTensorContent()</a>.  <br /></td></tr>
<tr class="separator:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a00830aa9d8da4892472df573b3bb1656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656">GetStringTensorContent</a> (void *buffer, size_t buffer_length, size_t *offsets, size_t offsets_count) const</td></tr>
<tr class="memdesc:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664" title="This API returns a full length of string data contained within either a tensor or a sparse Tensor....">GetStringTensorDataLength()</a> to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings.  <br /></td></tr>
<tr class="separator:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_aed947feb6d46847d3d6cc0289b377fe6"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aed947feb6d46847d3d6cc0289b377fe6">GetTensorData</a> () const</td></tr>
<tr class="memdesc:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const typed pointer to the tensor contained data. No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a183c3ebf0e4d24698a782674fb9cced0"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a183c3ebf0e4d24698a782674fb9cced0">GetTensorRawData</a> () const</td></tr>
<tr class="memdesc:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a5ff868faaa0f476137844f1fe6053e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a5ff868faaa0f476137844f1fe6053e42">GetTypeInfo</a> () const</td></tr>
<tr class="memdesc:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a9f945911eac6ee23534ce527488a6d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a9f945911eac6ee23534ce527488a6d5e">GetTensorTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a7342c33f055407202f6b0e4ed209ead0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_memory_info_impl.html">ConstMemoryInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a7342c33f055407202f6b0e4ed209ead0">GetTensorMemoryInfo</a> () const</td></tr>
<tr class="memdesc:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns information about the memory allocation used to hold data.  <br /></td></tr>
<tr class="separator:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a11173caf6ac2fdc03fb1c3981fec9b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a11173caf6ac2fdc03fb1c3981fec9b3d">GetStringTensorElement</a> (size_t buffer_length, size_t element_index, void *buffer) const</td></tr>
<tr class="memdesc:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717" title="The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare...">GetStringTensorElementLength()</a> to obtain the length of the buffer to allocate.  <br /></td></tr>
<tr class="separator:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2a3eb2f60e10b5d5832b57d46c611a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a1e2a3eb2f60e10b5d5832b57d46c611a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a1e2a3eb2f60e10b5d5832b57d46c611a">GetStringTensorElement</a> (size_t element_index) const</td></tr>
<tr class="memdesc:a1e2a3eb2f60e10b5d5832b57d46c611a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string tensor UTF-8 encoded string element. Use of this API is recommended over <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a11173caf6ac2fdc03fb1c3981fec9b3d" title="The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sp...">GetStringTensorElement()</a> that takes void* buffer pointer.  <br /></td></tr>
<tr class="separator:a1e2a3eb2f60e10b5d5832b57d46c611a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a21460daeba8be912b5d21ef9aa6dd717"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717">GetStringTensorElementLength</a> (size_t element_index) const</td></tr>
<tr class="memdesc:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare tensor values.  <br /></td></tr>
<tr class="separator:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_afc36132cb6a308a8beaa5ebaaf1aea58"><td class="memItemLeft" align="right" valign="top">OrtSparseFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#afc36132cb6a308a8beaa5ebaaf1aea58">GetSparseFormat</a> () const</td></tr>
<tr class="memdesc:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns the sparse data format this OrtValue holds in a sparse tensor. If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used the value returned is ORT_SPARSE_UNDEFINED.  <br /></td></tr>
<tr class="separator:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_ab986f32751dc04d125b310fb91b05ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7">GetSparseTensorValuesTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for stored non-zero values of the sparse tensor. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211" title="The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values....">GetSparseTensorValues()</a> to obtain values buffer pointer.  <br /></td></tr>
<tr class="separator:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a14f83505e75304b45d70c8e41e65a070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070">GetSparseTensorIndicesTypeShapeInfo</a> (OrtSparseIndicesFormat format) const</td></tr>
<tr class="memdesc:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd" title="The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience dat...">GetSparseTensorIndicesData()</a> to obtain pointer to indices buffer.  <br /></td></tr>
<tr class="separator:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a6100cd63b21154bf72baf191c52631cd"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd">GetSparseTensorIndicesData</a> (OrtSparseIndicesFormat indices_format, size_t &amp;num_indices) const</td></tr>
<tr class="memdesc:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070" title="The API returns type and shape information for the specified indices. Each supported indices have the...">GetSparseTensorIndicesTypeShapeInfo()</a>;.  <br /></td></tr>
<tr class="separator:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a446256778924195baf3e340711a6ef44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a446256778924195baf3e340711a6ef44">IsSparseTensor</a> () const</td></tr>
<tr class="memdesc:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the OrtValue contains a sparse tensor.  <br /></td></tr>
<tr class="separator:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl" id="r_a98ed067e5d11dde40386232f0ed33211"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211">GetSparseTensorValues</a> () const</td></tr>
<tr class="memdesc:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values. The API merely does casting. Make sure you are requesting the right data type by calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> first.  <br /></td></tr>
<tr class="separator:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_a8072f7970ea1835bddf9aa5038d972b4"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (contained_type *p) noexcept</td></tr>
<tr class="separator:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_a7f40aacd24f0ba79db2dae8165930498"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_a8f197409cc84018ee2fe04844f188959"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_a36ed2c8723bd744b585c65e214156665"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_ab10471dad43b6c80043d0714ae6544c9"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_aa04e81c6255e5907c49afc2324b80211"><td class="memItemLeft" align="right" valign="top">
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator contained_type *</b> () const noexcept</td></tr>
<tr class="separator:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base" id="r_a77e438d539c77870789686c70b031802"><td class="memItemLeft" align="right" valign="top">
contained_type *&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> ()</td></tr>
<tr class="memdesc:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquishes ownership of the contained C object pointer The underlying object is not destroyed. <br /></td></tr>
<tr class="separator:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base" id="r_ac618b65a5500fb65b7419b465cfd3d65"><td class="memItemLeft" align="right" valign="top">
contained_type *&#160;</td><td class="memItemRight" valign="bottom"><b>p_</b> {}</td></tr>
<tr class="separator:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a657fe9ca6bd6e2dc09c0beb95ee3e1eb" name="a657fe9ca6bd6e2dc09c0beb95ee3e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fe9ca6bd6e2dc09c0beb95ee3e1eb">&#9670;&#160;</a></span>At()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R &amp; <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>by the vector of dims.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>[in] expressed by a vecotr of dimensions offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a657fe9ca6bd6e2dc09c0beb95ee3e1eb_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a657fe9ca6bd6e2dc09c0beb95ee3e1eb_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a657fe9ca6bd6e2dc09c0beb95ee3e1eb_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a657fe9ca6bd6e2dc09c0beb95ee3e1eb_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,170,32"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="218,5,305,32"/>
<area shape="poly" title=" " alt="" coords="170,16,202,16,202,21,170,21"/>
</map>
</div>

</div>
</div>
<a id="a7a57d606a608abda7df7b9b23a301a3e" name="a7a57d606a608abda7df7b9b23a301a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a57d606a608abda7df7b9b23a301a3e">&#9670;&#160;</a></span>FillSparseTensorBlockSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorBlockSparse </td>
          <td>(</td>
          <td class="paramtype">const OrtMemoryInfo *</td>          <td class="paramname"><span class="paramname"><em>data_mem_info</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indices_shape</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *</td>          <td class="paramname"><span class="paramname"><em>indices_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">indices_shape</td><td>indices shape. use {0} for fully sparse tensors</td></tr>
    <tr><td class="paramname">indices_data</td><td>pointer to indices data or nullptr for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a7a57d606a608abda7df7b9b23a301a3e_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a7a57d606a608abda7df7b9b23a301a3e_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a7a57d606a608abda7df7b9b23a301a3e_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a7a57d606a608abda7df7b9b23a301a3e_cgraph">
<area shape="rect" title="The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API an..." alt="" coords="5,5,206,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="254,13,341,40"/>
<area shape="poly" title=" " alt="" coords="206,24,238,24,238,29,206,29"/>
</map>
</div>

</div>
</div>
<a id="ab30c08c17ce26d0c89e8c7dea62f9a75" name="ab30c08c17ce26d0c89e8c7dea62f9a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30c08c17ce26d0c89e8c7dea62f9a75">&#9670;&#160;</a></span>FillSparseTensorCoo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorCoo </td>
          <td>(</td>
          <td class="paramtype">const OrtMemoryInfo *</td>          <td class="paramname"><span class="paramname"><em>data_mem_info</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>values_param</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *</td>          <td class="paramname"><span class="paramname"><em>indices_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>indices_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values_param</td><td>values buffer information.</td></tr>
    <tr><td class="paramname">indices_data</td><td>coo indices buffer or nullptr for fully sparse data</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of COO indices or 0 for fully sparse data</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_ab30c08c17ce26d0c89e8c7dea62f9a75_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_ab30c08c17ce26d0c89e8c7dea62f9a75_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_ab30c08c17ce26d0c89e8c7dea62f9a75_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_ab30c08c17ce26d0c89e8c7dea62f9a75_cgraph">
<area shape="rect" title="The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API an..." alt="" coords="5,5,155,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="203,13,290,40"/>
<area shape="poly" title=" " alt="" coords="155,24,187,24,187,29,155,29"/>
</map>
</div>

</div>
</div>
<a id="af67cc830bdf35e40717b06ca70b22ead" name="af67cc830bdf35e40717b06ca70b22ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67cc830bdf35e40717b06ca70b22ead">&#9670;&#160;</a></span>FillSparseTensorCsr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorCsr </td>
          <td>(</td>
          <td class="paramtype">const OrtMemoryInfo *</td>          <td class="paramname"><span class="paramname"><em>data_mem_info</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *</td>          <td class="paramname"><span class="paramname"><em>inner_indices_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>inner_indices_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *</td>          <td class="paramname"><span class="paramname"><em>outer_indices_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>outer_indices_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">inner_indices_data</td><td>csr inner indices pointer or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_indices_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_data</td><td>pointer to csr indices data or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_num</td><td>number of csr outer indices or 0</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_af67cc830bdf35e40717b06ca70b22ead_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_af67cc830bdf35e40717b06ca70b22ead_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_af67cc830bdf35e40717b06ca70b22ead_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_af67cc830bdf35e40717b06ca70b22ead_cgraph">
<area shape="rect" title="The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API an..." alt="" coords="5,5,152,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="200,13,287,40"/>
<area shape="poly" title=" " alt="" coords="152,24,184,24,184,29,152,29"/>
</map>
</div>

</div>
</div>
<a id="ac98717a93e02f4b91ebabaf3c4ab891c" name="ac98717a93e02f4b91ebabaf3c4ab891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98717a93e02f4b91ebabaf3c4ab891c">&#9670;&#160;</a></span>FillStringTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillStringTensor </td>
          <td>(</td>
          <td class="paramtype">const char *const *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>s_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all strings at once in a string tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>[in] An array of strings. Each string in this array must be null terminated.</td></tr>
    <tr><td class="paramname">s_len</td><td>[in] Count of strings in s (Must match the size of <code>value's</code> tensor shape)</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_ac98717a93e02f4b91ebabaf3c4ab891c_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_ac98717a93e02f4b91ebabaf3c4ab891c_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_ac98717a93e02f4b91ebabaf3c4ab891c_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_ac98717a93e02f4b91ebabaf3c4ab891c_cgraph">
<area shape="rect" title="Set all strings at once in a string tensor." alt="" coords="5,5,149,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="197,13,284,40"/>
<area shape="poly" title=" " alt="" coords="149,24,181,24,181,29,149,29"/>
</map>
</div>

</div>
</div>
<a id="a0a59534f82ccf9ff55b8a692270e4503" name="a0a59534f82ccf9ff55b8a692270e4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a59534f82ccf9ff55b8a692270e4503">&#9670;&#160;</a></span>FillStringTensorElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillStringTensorElement </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single string in a string tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>[in] A null terminated UTF-8 encoded string</td></tr>
    <tr><td class="paramname">index</td><td>[in] Index of the string in the tensor to set</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a0a59534f82ccf9ff55b8a692270e4503_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a0a59534f82ccf9ff55b8a692270e4503_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a0a59534f82ccf9ff55b8a692270e4503_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a0a59534f82ccf9ff55b8a692270e4503_cgraph">
<area shape="rect" title="Set a single string in a string tensor." alt="" coords="5,5,173,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="221,13,308,40"/>
<area shape="poly" title=" " alt="" coords="173,24,205,24,205,29,173,29"/>
</map>
</div>

</div>
</div>
<a id="afbde85d0a4ef2f1a38ff369d218ec56c" name="afbde85d0a4ef2f1a38ff369d218ec56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbde85d0a4ef2f1a38ff369d218ec56c">&#9670;&#160;</a></span>GetResizedStringTensorElementBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::GetResizedStringTensorElementBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buffer_length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate if necessary and obtain a pointer to a UTF-8 encoded string element buffer indexed by the flat element index, of the specified length. </p>
<p>This API is for advanced usage. It avoids a need to construct an auxiliary array of string pointers, and allows to write data directly (do not zero terminate).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
    <tr><td class="paramname">buffer_length</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a writable buffer</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_afbde85d0a4ef2f1a38ff369d218ec56c_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_afbde85d0a4ef2f1a38ff369d218ec56c_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_afbde85d0a4ef2f1a38ff369d218ec56c_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_afbde85d0a4ef2f1a38ff369d218ec56c_cgraph">
<area shape="rect" title="Allocate if necessary and obtain a pointer to a UTF&#45;8 encoded string element buffer indexed by the fl..." alt="" coords="5,5,224,64"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="272,21,359,48"/>
<area shape="poly" title=" " alt="" coords="224,32,256,32,256,37,224,37"/>
</map>
</div>

</div>
</div>
<a id="a28317ae875d9c8b35f0cbed64f776c5a" name="a28317ae875d9c8b35f0cbed64f776c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28317ae875d9c8b35f0cbed64f776c5a">&#9670;&#160;</a></span>GetTensorMutableData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R * <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::GetTensorMutableData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-const typed pointer to an OrtValue/Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type. </p>
<dl class="section return"><dt>Returns</dt><dd>non-const pointer to data, no copies made</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a28317ae875d9c8b35f0cbed64f776c5a_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a28317ae875d9c8b35f0cbed64f776c5a_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a28317ae875d9c8b35f0cbed64f776c5a_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a28317ae875d9c8b35f0cbed64f776c5a_cgraph">
<area shape="rect" title="Returns a non&#45;const typed pointer to an OrtValue/Tensor contained buffer No type checking is performe..." alt="" coords="5,5,168,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="216,13,303,40"/>
<area shape="poly" title=" " alt="" coords="168,24,200,24,200,29,168,29"/>
</map>
</div>

</div>
</div>
<a id="a8b55de64b5457b5fd0538ec8225a0507" name="a8b55de64b5457b5fd0538ec8225a0507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b55de64b5457b5fd0538ec8225a0507">&#9670;&#160;</a></span>GetTensorMutableRawData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::GetTensorMutableRawData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-typed non-const pointer to a tensor contained data. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data, no copies made</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a8b55de64b5457b5fd0538ec8225a0507_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a8b55de64b5457b5fd0538ec8225a0507_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a8b55de64b5457b5fd0538ec8225a0507_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a8b55de64b5457b5fd0538ec8225a0507_cgraph">
<area shape="rect" title="Returns a non&#45;typed non&#45;const pointer to a tensor contained data." alt="" coords="5,5,193,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="241,13,328,40"/>
<area shape="poly" title=" " alt="" coords="193,24,225,24,225,29,193,29"/>
</map>
</div>

</div>
</div>
<a id="a68ba9e6d44e6a1141c04d1fefaa3b6c6" name="a68ba9e6d44e6a1141c04d1fefaa3b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ba9e6d44e6a1141c04d1fefaa3b6c6">&#9670;&#160;</a></span>UseBlockSparseIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseBlockSparseIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indices_shape</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *</td>          <td class="paramname"><span class="paramname"><em>indices_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_shape</td><td>indices shape or a {0} for fully sparse</td></tr>
    <tr><td class="paramname">indices_data</td><td>user allocated buffer with indices or nullptr for fully spare tensors</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a68ba9e6d44e6a1141c04d1fefaa3b6c6_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a68ba9e6d44e6a1141c04d1fefaa3b6c6_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a68ba9e6d44e6a1141c04d1fefaa3b6c6_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a68ba9e6d44e6a1141c04d1fefaa3b6c6_cgraph">
<area shape="rect" title="Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSp..." alt="" coords="5,5,173,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="221,13,308,40"/>
<area shape="poly" title=" " alt="" coords="173,24,205,24,205,29,173,29"/>
</map>
</div>

</div>
</div>
<a id="a8b80e2a725f45cdeceb06bcba643e978" name="a8b80e2a725f45cdeceb06bcba643e978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80e2a725f45cdeceb06bcba643e978">&#9670;&#160;</a></span>UseCooIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseCooIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>indices_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>indices_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_data</td><td>pointer to the user allocated buffer with indices. Use nullptr for fully sparse tensors.</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of indices entries. Use 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_a8b80e2a725f45cdeceb06bcba643e978_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_a8b80e2a725f45cdeceb06bcba643e978_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_a8b80e2a725f45cdeceb06bcba643e978_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_a8b80e2a725f45cdeceb06bcba643e978_cgraph">
<area shape="rect" title="Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tens..." alt="" coords="5,5,149,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="197,13,284,40"/>
<area shape="poly" title=" " alt="" coords="149,24,181,24,181,29,149,29"/>
</map>
</div>

</div>
</div>
<a id="adc53699ae881046ccf26527fb0e0d7d2" name="adc53699ae881046ccf26527fb0e0d7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc53699ae881046ccf26527fb0e0d7d2">&#9670;&#160;</a></span>UseCsrIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseCsrIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>inner_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>inner_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>outer_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>outer_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner_data</td><td>pointer to the user allocated buffer with inner indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_data</td><td>pointer to the user allocated buffer with outer indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_num</td><td>number of csr outer indices or 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="struct_ort_1_1detail_1_1_value_impl_adc53699ae881046ccf26527fb0e0d7d2_cgraph.png" border="0" usemap="#astruct_ort_1_1detail_1_1_value_impl_adc53699ae881046ccf26527fb0e0d7d2_cgraph" alt=""/></div>
<map name="astruct_ort_1_1detail_1_1_value_impl_adc53699ae881046ccf26527fb0e0d7d2_cgraph" id="astruct_ort_1_1detail_1_1_value_impl_adc53699ae881046ccf26527fb0e0d7d2_cgraph">
<area shape="rect" title="Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tens..." alt="" coords="5,5,149,48"/>
<area shape="rect" href="namespace_ort.html#a296b5958479d9889218b17bdb08c1894" title="This returns a reference to the OrtApi interface in use." alt="" coords="197,13,284,40"/>
<area shape="poly" title=" " alt="" coords="149,24,181,24,181,29,149,29"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>C:/Users/m5963/Documents/GitHub/AnimHost/AnimHost/animHost_Plugins/BasicOnnxPlugin/onnxruntime/include/<a class="el" href="onnxruntime__cxx__api_8h_source.html">onnxruntime_cxx_api.h</a></li>
<li>C:/Users/m5963/Documents/GitHub/AnimHost/AnimHost/animHost_Plugins/BasicOnnxPlugin/onnxruntime/include/<a class="el" href="onnxruntime__cxx__inline_8h_source.html">onnxruntime_cxx_inline.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
