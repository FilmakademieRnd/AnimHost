\doxysection{Ort\+::detail\+::Base\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Struct Template Reference}
\hypertarget{struct_ort_1_1detail_1_1_base}{}\label{struct_ort_1_1detail_1_1_base}\index{Ort::detail::Base$<$ T $>$@{Ort::detail::Base$<$ T $>$}}


Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction to wrap the C API objects and delete them on destruction.  




{\ttfamily \#include $<$onnxruntime\+\_\+cxx\+\_\+api.\+h$>$}



Inheritance diagram for Ort\+::detail\+::Base\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{struct_ort_1_1detail_1_1_base__inherit__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_adac6328b9d9b37cddd94f6b21bebee74}\label{struct_ort_1_1detail_1_1_base_adac6328b9d9b37cddd94f6b21bebee74} 
using {\bfseries contained\+\_\+type} = T
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_a8072f7970ea1835bddf9aa5038d972b4}\label{struct_ort_1_1detail_1_1_base_a8072f7970ea1835bddf9aa5038d972b4} 
constexpr {\bfseries Base} (contained\+\_\+type \texorpdfstring{$\ast$}{*}p) noexcept
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_a7f40aacd24f0ba79db2dae8165930498}\label{struct_ort_1_1detail_1_1_base_a7f40aacd24f0ba79db2dae8165930498} 
{\bfseries Base} (const \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&)=delete
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_a8f197409cc84018ee2fe04844f188959}\label{struct_ort_1_1detail_1_1_base_a8f197409cc84018ee2fe04844f188959} 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \& {\bfseries operator=} (const \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&)=delete
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_a36ed2c8723bd744b585c65e214156665}\label{struct_ort_1_1detail_1_1_base_a36ed2c8723bd744b585c65e214156665} 
{\bfseries Base} (\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&\&v) noexcept
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_ab10471dad43b6c80043d0714ae6544c9}\label{struct_ort_1_1detail_1_1_base_ab10471dad43b6c80043d0714ae6544c9} 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \& {\bfseries operator=} (\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&\&v) noexcept
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_aa04e81c6255e5907c49afc2324b80211}\label{struct_ort_1_1detail_1_1_base_aa04e81c6255e5907c49afc2324b80211} 
constexpr {\bfseries operator contained\+\_\+type \texorpdfstring{$\ast$}{*}} () const noexcept
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_a77e438d539c77870789686c70b031802}\label{struct_ort_1_1detail_1_1_base_a77e438d539c77870789686c70b031802} 
contained\+\_\+type \texorpdfstring{$\ast$}{*} {\bfseries release} ()
\begin{DoxyCompactList}\small\item\em Relinquishes ownership of the contained C object pointer The underlying object is not destroyed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_ort_1_1detail_1_1_base_ac618b65a5500fb65b7419b465cfd3d65}\label{struct_ort_1_1detail_1_1_base_ac618b65a5500fb65b7419b465cfd3d65} 
contained\+\_\+type \texorpdfstring{$\ast$}{*} {\bfseries p\+\_\+} \{\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
struct Ort\+::detail\+::\+Base$<$ T $>$}
Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction to wrap the C API objects and delete them on destruction. 

All of the C++ classes a) serve as containers for pointers to objects that are created by the underlying C API. Their size is just a pointer size, no need to dynamically allocate them. Use them by value. b) Each of struct XXXX, XXX instances function as smart pointers to the underlying C API objects. they would release objects owned automatically when going out of scope, they are move-\/only. c) Const\+XXXX and Unowned\+XXX structs function as non-\/owning, copyable containers for the above pointers. Const\+XXXX allow calling const interfaces only. They give access to objects that are owned by somebody else such as Onnxruntime or instances of XXXX classes. d) serve convenient interfaces that return C++ objects and further enhance exception and type safety so they can be used in C++ code.

This is a non-\/const pointer holder that is move-\/only. Disposes of the pointer on destruction. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/m5963/\+Documents/\+Git\+Hub/\+Anim\+Host/\+Anim\+Host/anim\+Host\+\_\+\+Plugins/\+Basic\+Onnx\+Plugin/onnxruntime/include/onnxruntime\+\_\+cxx\+\_\+api.\+h\end{DoxyCompactItemize}
