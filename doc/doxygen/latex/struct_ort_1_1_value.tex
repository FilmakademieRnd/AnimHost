\doxysection{Ort\+::Value Struct Reference}
\hypertarget{struct_ort_1_1_value}{}\label{struct_ort_1_1_value}\index{Ort::Value@{Ort::Value}}


Wrapper around \doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Value}.  




{\ttfamily \#include $<$onnxruntime\+\_\+cxx\+\_\+api.\+h$>$}



Inheritance diagram for Ort\+::Value\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{struct_ort_1_1_value__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Ort\+::Value\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{struct_ort_1_1_value__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_ort_1_1_value_acaa37dd471180adc7e0feba8bee065c9}\label{struct_ort_1_1_value_acaa37dd471180adc7e0feba8bee065c9} 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{using}} {\bfseries Base} = \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl}{detail\+::\+Value\+Impl}}$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Value}}$>$
\item 
\Hypertarget{struct_ort_1_1_value_a488c55bbedb38c3f505a4fe6accc36bf}\label{struct_ort_1_1_value_a488c55bbedb38c3f505a4fe6accc36bf} 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{using}} {\bfseries Ort\+Sparse\+Values\+Param} = \mbox{\hyperlink{struct_ort_1_1detail_1_1_ort_sparse_values_param}{detail\+::\+Ort\+Sparse\+Values\+Param}}
\item 
\Hypertarget{struct_ort_1_1_value_aa887af73b5a841819423295063c10836}\label{struct_ort_1_1_value_aa887af73b5a841819423295063c10836} 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{using}} {\bfseries Shape} = \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{detail\+::\+Shape}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl}{Ort\+::detail\+::\+Value\+Impl$<$ Ort\+Value $>$}}}
\begin{DoxyCompactItemize}
\item 
using {\bfseries B}
\item 
using {\bfseries B}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl}{Ort\+::detail\+::\+Const\+Value\+Impl$<$ T $>$}}}
\begin{DoxyCompactItemize}
\item 
using {\bfseries B} = \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}}$<$T$>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Ort\+::detail\+::\+Base$<$ T $>$}}}
\begin{DoxyCompactItemize}
\item 
using {\bfseries contained\+\_\+type} = T
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_ort_1_1_value_a233d9a9878a69295ad504ea2b22b4d1f}\label{struct_ort_1_1_value_a233d9a9878a69295ad504ea2b22b4d1f} 
{\bfseries Value} (std\+::nullptr\+\_\+t)
\begin{DoxyCompactList}\small\item\em Create an empty \doxylink{struct_ort_1_1_value}{Value} object, must be assigned a valid one to be used. \end{DoxyCompactList}\item 
\Hypertarget{struct_ort_1_1_value_a4e744a54c1fe6c477cccbe33b580fe3b}\label{struct_ort_1_1_value_a4e744a54c1fe6c477cccbe33b580fe3b} 
{\bfseries Value} (\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Value}} \texorpdfstring{$\ast$}{*}p)
\begin{DoxyCompactList}\small\item\em Used for interop with the C API. \end{DoxyCompactList}\item 
\Hypertarget{struct_ort_1_1_value_a1b7884f57758a06ca3b1203fcff98a08}\label{struct_ort_1_1_value_a1b7884f57758a06ca3b1203fcff98a08} 
{\bfseries Value} (\mbox{\hyperlink{struct_ort_1_1_value}{Value}} \&\&)=\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{default}}
\item 
\Hypertarget{struct_ort_1_1_value_a14ce9c0a1b41a61eb0f94bc9070539eb}\label{struct_ort_1_1_value_a14ce9c0a1b41a61eb0f94bc9070539eb} 
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} \& {\bfseries operator=} (\mbox{\hyperlink{struct_ort_1_1_value}{Value}} \&\&)=\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{default}}
\item 
\Hypertarget{struct_ort_1_1_value_ae7df58aec9512b5744e9869b0360ee77}\label{struct_ort_1_1_value_ae7df58aec9512b5744e9869b0360ee77} 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl}{Const\+Value}} {\bfseries Get\+Const} () \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}}
\item 
\Hypertarget{struct_ort_1_1_value_a5def834adf6750b31b7fdead89b67a07}\label{struct_ort_1_1_value_a5def834adf6750b31b7fdead89b67a07} 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl}{Unowned\+Value}} {\bfseries Get\+Unowned} () \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl}{Ort\+::detail\+::\+Value\+Impl$<$ Ort\+Value $>$}}}
\begin{DoxyCompactItemize}
\item 
R \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a28317ae875d9c8b35f0cbed64f776c5a}{Get\+Tensor\+Mutable\+Data}} ()
\begin{DoxyCompactList}\small\item\em Returns a non-\/const typed pointer to an Ort\+Value/\+Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type. \end{DoxyCompactList}\item 
void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a8b55de64b5457b5fd0538ec8225a0507}{Get\+Tensor\+Mutable\+Raw\+Data}} ()
\begin{DoxyCompactList}\small\item\em Returns a non-\/typed non-\/const pointer to a tensor contained data. \end{DoxyCompactList}\item 
R \& \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a657fe9ca6bd6e2dc09c0beb95ee3e1eb}{At}} (const std\+::vector$<$ int64\+\_\+t $>$ \&location)
\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_ac98717a93e02f4b91ebabaf3c4ab891c}{Fill\+String\+Tensor}} (const char \texorpdfstring{$\ast$}{*}const \texorpdfstring{$\ast$}{*}s, size\+\_\+t s\+\_\+len)
\begin{DoxyCompactList}\small\item\em Set all strings at once in a string tensor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a0a59534f82ccf9ff55b8a692270e4503}{Fill\+String\+Tensor\+Element}} (const char \texorpdfstring{$\ast$}{*}s, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Set a single string in a string tensor. \end{DoxyCompactList}\item 
char \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_afbde85d0a4ef2f1a38ff369d218ec56c}{Get\+Resized\+String\+Tensor\+Element\+Buffer}} (size\+\_\+t index, size\+\_\+t buffer\+\_\+length)
\begin{DoxyCompactList}\small\item\em Allocate if necessary and obtain a pointer to a UTF-\/8 encoded string element buffer indexed by the flat element index, of the specified length. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a8b80e2a725f45cdeceb06bcba643e978}{Use\+Coo\+Indices}} (int64\+\_\+t \texorpdfstring{$\ast$}{*}indices\+\_\+data, size\+\_\+t indices\+\_\+num)
\begin{DoxyCompactList}\small\item\em Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a Create\+Sparse\+Tensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the Ort\+Value. The location of the indices is assumed to be the same as specified by Ort\+Memory\+Info argument at the creation time. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_adc53699ae881046ccf26527fb0e0d7d2}{Use\+Csr\+Indices}} (int64\+\_\+t \texorpdfstring{$\ast$}{*}inner\+\_\+data, size\+\_\+t inner\+\_\+num, int64\+\_\+t \texorpdfstring{$\ast$}{*}outer\+\_\+data, size\+\_\+t outer\+\_\+num)
\begin{DoxyCompactList}\small\item\em Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a Create\+Sparse\+Tensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the Ort\+Value. The location of the indices is assumed to be the same as specified by Ort\+Memory\+Info argument at the creation time. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a68ba9e6d44e6a1141c04d1fefaa3b6c6}{Use\+Block\+Sparse\+Indices}} (const \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&indices\+\_\+shape, int32\+\_\+t \texorpdfstring{$\ast$}{*}indices\+\_\+data)
\begin{DoxyCompactList}\small\item\em Supplies Block\+Sparse format specific indices and marks the contained sparse tensor as being a Block\+Sparse format tensor. Values are supplied with a Create\+Sparse\+Tensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the Ort\+Value. The location of the indices is assumed to be the same as specified by Ort\+Memory\+Info argument at the creation time. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_ab30c08c17ce26d0c89e8c7dea62f9a75}{Fill\+Sparse\+Tensor\+Coo}} (const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}data\+\_\+mem\+\_\+info, const \mbox{\hyperlink{struct_ort_1_1detail_1_1_ort_sparse_values_param}{Ort\+Sparse\+Values\+Param}} \&values\+\_\+param, const int64\+\_\+t \texorpdfstring{$\ast$}{*}indices\+\_\+data, size\+\_\+t indices\+\_\+num)
\begin{DoxyCompactList}\small\item\em The API will allocate memory using the allocator instance supplied to the Create\+Sparse\+Tensor() API and copy the values and COO indices into it. If data\+\_\+mem\+\_\+info specifies that the data is located at difference device than the allocator, a X-\/device copy will be performed if possible. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_af67cc830bdf35e40717b06ca70b22ead}{Fill\+Sparse\+Tensor\+Csr}} (const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}data\+\_\+mem\+\_\+info, const \mbox{\hyperlink{struct_ort_1_1detail_1_1_ort_sparse_values_param}{Ort\+Sparse\+Values\+Param}} \&values, const int64\+\_\+t \texorpdfstring{$\ast$}{*}inner\+\_\+indices\+\_\+data, size\+\_\+t inner\+\_\+indices\+\_\+num, const int64\+\_\+t \texorpdfstring{$\ast$}{*}outer\+\_\+indices\+\_\+data, size\+\_\+t outer\+\_\+indices\+\_\+num)
\begin{DoxyCompactList}\small\item\em The API will allocate memory using the allocator instance supplied to the Create\+Sparse\+Tensor() API and copy the values and CSR indices into it. If data\+\_\+mem\+\_\+info specifies that the data is located at difference device than the allocator, a X-\/device copy will be performed if possible. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_value_impl_a7a57d606a608abda7df7b9b23a301a3e}{Fill\+Sparse\+Tensor\+Block\+Sparse}} (const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}data\+\_\+mem\+\_\+info, const \mbox{\hyperlink{struct_ort_1_1detail_1_1_ort_sparse_values_param}{Ort\+Sparse\+Values\+Param}} \&values, const \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&indices\+\_\+shape, const int32\+\_\+t \texorpdfstring{$\ast$}{*}indices\+\_\+data)
\begin{DoxyCompactList}\small\item\em The API will allocate memory using the allocator instance supplied to the Create\+Sparse\+Tensor() API and copy the values and Block\+Sparse indices into it. If data\+\_\+mem\+\_\+info specifies that the data is located at difference device than the allocator, a X-\/device copy will be performed if possible. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl}{Ort\+::detail\+::\+Const\+Value\+Impl$<$ T $>$}}}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename R $>$ }\\void \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_ab541b268a2aad607ceec3a3da7be8ba0}{Get\+Opaque\+Data}} (const char \texorpdfstring{$\ast$}{*}domain, const char \texorpdfstring{$\ast$}{*}type\+\_\+name, R \&) const
\begin{DoxyCompactList}\small\item\em Obtains a pointer to a user defined data for experimental purposes. \end{DoxyCompactList}\item 
bool {\bfseries Is\+Tensor} () const
\begin{DoxyCompactList}\small\item\em Returns true if \doxylink{struct_ort_1_1_value}{Value} is a tensor, false for other types like map/sequence/etc. \end{DoxyCompactList}\item 
bool {\bfseries Has\+Value} () const
\item 
size\+\_\+t {\bfseries Get\+Count} () const
\begin{DoxyCompactList}\small\item\em \texorpdfstring{$<$}{<} Return true if Ort\+Value contains data and returns false if the Ort\+Value is a None \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} {\bfseries Get\+Value} (int index, \mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}allocator) const
\item 
size\+\_\+t \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a2700d2f2a5d9a7922c81419cc9fed664}{Get\+String\+Tensor\+Data\+Length}} () const
\begin{DoxyCompactList}\small\item\em This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-\/empty strings (values). The API is useful for allocating necessary memory and calling \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a00830aa9d8da4892472df573b3bb1656}{Get\+String\+Tensor\+Content()}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a00830aa9d8da4892472df573b3bb1656}{Get\+String\+Tensor\+Content}} (void \texorpdfstring{$\ast$}{*}buffer, size\+\_\+t buffer\+\_\+length, size\+\_\+t \texorpdfstring{$\ast$}{*}offsets, size\+\_\+t offsets\+\_\+count) const
\begin{DoxyCompactList}\small\item\em The API copies all of the UTF-\/8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a2700d2f2a5d9a7922c81419cc9fed664}{Get\+String\+Tensor\+Data\+Length()} to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename R $>$ }\\const R \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_aed947feb6d46847d3d6cc0289b377fe6}{Get\+Tensor\+Data}} () const
\begin{DoxyCompactList}\small\item\em Returns a const typed pointer to the tensor contained data. No type checking is performed, the caller must ensure the type matches the tensor type. \end{DoxyCompactList}\item 
const void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a183c3ebf0e4d24698a782674fb9cced0}{Get\+Tensor\+Raw\+Data}} () const
\begin{DoxyCompactList}\small\item\em Returns a non-\/typed pointer to a tensor contained data. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_type_info}{Type\+Info}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a5ff868faaa0f476137844f1fe6053e42}{Get\+Type\+Info}} () const
\begin{DoxyCompactList}\small\item\em The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-\/zero values. It returns dense shape for sparse tensors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_tensor_type_and_shape_info}{Tensor\+Type\+And\+Shape\+Info}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a9f945911eac6ee23534ce527488a6d5e}{Get\+Tensor\+Type\+And\+Shape\+Info}} () const
\begin{DoxyCompactList}\small\item\em The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-\/zero values. It returns dense shape for sparse tensors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_memory_info_impl}{Const\+Memory\+Info}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a7342c33f055407202f6b0e4ed209ead0}{Get\+Tensor\+Memory\+Info}} () const
\begin{DoxyCompactList}\small\item\em This API returns information about the memory allocation used to hold data. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a11173caf6ac2fdc03fb1c3981fec9b3d}{Get\+String\+Tensor\+Element}} (size\+\_\+t buffer\+\_\+length, size\+\_\+t element\+\_\+index, void \texorpdfstring{$\ast$}{*}buffer) const
\begin{DoxyCompactList}\small\item\em The API copies UTF-\/8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a21460daeba8be912b5d21ef9aa6dd717}{Get\+String\+Tensor\+Element\+Length()} to obtain the length of the buffer to allocate. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a1e2a3eb2f60e10b5d5832b57d46c611a}{Get\+String\+Tensor\+Element}} (size\+\_\+t element\+\_\+index) const
\begin{DoxyCompactList}\small\item\em Returns string tensor UTF-\/8 encoded string element. Use of this API is recommended over \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a11173caf6ac2fdc03fb1c3981fec9b3d}{Get\+String\+Tensor\+Element()} that takes void\texorpdfstring{$\ast$}{*} buffer pointer. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a21460daeba8be912b5d21ef9aa6dd717}{Get\+String\+Tensor\+Element\+Length}} (size\+\_\+t element\+\_\+index) const
\begin{DoxyCompactList}\small\item\em The API returns a byte length of UTF-\/8 encoded string element contained in either a tensor or a spare tensor values. \end{DoxyCompactList}\item 
Ort\+Sparse\+Format \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_afc36132cb6a308a8beaa5ebaaf1aea58}{Get\+Sparse\+Format}} () const
\begin{DoxyCompactList}\small\item\em The API returns the sparse data format this Ort\+Value holds in a sparse tensor. If the sparse tensor was not fully constructed, i.\+e. Use\texorpdfstring{$\ast$}{*}() or Fill\texorpdfstring{$\ast$}{*}() API were not used the value returned is ORT\+\_\+\+SPARSE\+\_\+\+UNDEFINED. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_tensor_type_and_shape_info}{Tensor\+Type\+And\+Shape\+Info}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_ab986f32751dc04d125b310fb91b05ab7}{Get\+Sparse\+Tensor\+Values\+Type\+And\+Shape\+Info}} () const
\begin{DoxyCompactList}\small\item\em The API returns type and shape information for stored non-\/zero values of the sparse tensor. Use \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a98ed067e5d11dde40386232f0ed33211}{Get\+Sparse\+Tensor\+Values()} to obtain values buffer pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_tensor_type_and_shape_info}{Tensor\+Type\+And\+Shape\+Info}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a14f83505e75304b45d70c8e41e65a070}{Get\+Sparse\+Tensor\+Indices\+Type\+Shape\+Info}} (Ort\+Sparse\+Indices\+Format format) const
\begin{DoxyCompactList}\small\item\em The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a6100cd63b21154bf72baf191c52631cd}{Get\+Sparse\+Tensor\+Indices\+Data()} to obtain pointer to indices buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename R $>$ }\\const R \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a6100cd63b21154bf72baf191c52631cd}{Get\+Sparse\+Tensor\+Indices\+Data}} (Ort\+Sparse\+Indices\+Format indices\+\_\+format, size\+\_\+t \&num\+\_\+indices) const
\begin{DoxyCompactList}\small\item\em The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use \doxylink{struct_ort_1_1detail_1_1_const_value_impl_a14f83505e75304b45d70c8e41e65a070}{Get\+Sparse\+Tensor\+Indices\+Type\+Shape\+Info()};. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a446256778924195baf3e340711a6ef44}{Is\+Sparse\+Tensor}} () const
\begin{DoxyCompactList}\small\item\em Returns true if the Ort\+Value contains a sparse tensor. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename R $>$ }\\const R \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_ort_1_1detail_1_1_const_value_impl_a98ed067e5d11dde40386232f0ed33211}{Get\+Sparse\+Tensor\+Values}} () const
\begin{DoxyCompactList}\small\item\em The API returns a pointer to an internal buffer of the sparse tensor containing non-\/zero values. The API merely does casting. Make sure you are requesting the right data type by calling \doxylink{struct_ort_1_1detail_1_1_const_value_impl_ab986f32751dc04d125b310fb91b05ab7}{Get\+Sparse\+Tensor\+Values\+Type\+And\+Shape\+Info()} first. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Ort\+::detail\+::\+Base$<$ T $>$}}}
\begin{DoxyCompactItemize}
\item 
constexpr {\bfseries Base} (contained\+\_\+type \texorpdfstring{$\ast$}{*}p) noexcept
\item 
{\bfseries Base} (const \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&)=delete
\item 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \& {\bfseries operator=} (const \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&)=delete
\item 
{\bfseries Base} (\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&\&v) noexcept
\item 
\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \& {\bfseries operator=} (\mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Base}} \&\&v) noexcept
\item 
constexpr {\bfseries operator contained\+\_\+type \texorpdfstring{$\ast$}{*}} () const noexcept
\item 
contained\+\_\+type \texorpdfstring{$\ast$}{*} {\bfseries release} ()
\begin{DoxyCompactList}\small\item\em Relinquishes ownership of the contained C object pointer The underlying object is not destroyed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\static \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Create\+Tensor}} (const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}info, T \texorpdfstring{$\ast$}{*}p\+\_\+data, size\+\_\+t p\+\_\+data\+\_\+element\+\_\+count, const int64\+\_\+t \texorpdfstring{$\ast$}{*}shape, size\+\_\+t shape\+\_\+len)
\begin{DoxyCompactList}\small\item\em Creates a tensor with a user supplied buffer. Wraps Ort\+Api\+::\+Create\+Tensor\+With\+Data\+As\+Ort\+Value. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a30dfeeee6f819d5c9df530cb164e4626}{Create\+Tensor}} (const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}info, void \texorpdfstring{$\ast$}{*}p\+\_\+data, size\+\_\+t p\+\_\+data\+\_\+byte\+\_\+count, const int64\+\_\+t \texorpdfstring{$\ast$}{*}shape, size\+\_\+t shape\+\_\+len, \mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}} type)
\begin{DoxyCompactList}\small\item\em Creates a tensor with a user supplied buffer. Wraps Ort\+Api\+::\+Create\+Tensor\+With\+Data\+As\+Ort\+Value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_ae6214620fce2d87d9015ab44ebec0a11}{Create\+Tensor}} (\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}allocator, const int64\+\_\+t \texorpdfstring{$\ast$}{*}shape, size\+\_\+t shape\+\_\+len)
\begin{DoxyCompactList}\small\item\em Creates a tensor using a supplied \doxylink{struct_ort_allocator}{Ort\+Allocator}. Wraps Ort\+Api\+::\+Create\+Tensor\+As\+Ort\+Value. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a29ade31d524988ca8b461ca62b88c21a}{Create\+Tensor}} (\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}allocator, const int64\+\_\+t \texorpdfstring{$\ast$}{*}shape, size\+\_\+t shape\+\_\+len, \mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}} type)
\begin{DoxyCompactList}\small\item\em Creates a tensor using a supplied \doxylink{struct_ort_allocator}{Ort\+Allocator}. Wraps Ort\+Api\+::\+Create\+Tensor\+As\+Ort\+Value. \end{DoxyCompactList}\item 
\Hypertarget{struct_ort_1_1_value_a6b8285d4630300fcc313cd10a2acba30}\label{struct_ort_1_1_value_a6b8285d4630300fcc313cd10a2acba30} 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} {\bfseries Create\+Map} (\mbox{\hyperlink{struct_ort_1_1_value}{Value}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{keys}}, \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{values}})
\begin{DoxyCompactList}\small\item\em Wraps Ort\+Api\+::\+Create\+Value. \end{DoxyCompactList}\item 
\Hypertarget{struct_ort_1_1_value_aa3f882f8fa47dadd335c07b350db954d}\label{struct_ort_1_1_value_aa3f882f8fa47dadd335c07b350db954d} 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} {\bfseries Create\+Sequence} (std\+::vector$<$ \mbox{\hyperlink{struct_ort_1_1_value}{Value}} $>$ \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{values}})
\begin{DoxyCompactList}\small\item\em Wraps Ort\+Api\+::\+Create\+Value. \end{DoxyCompactList}\item 
\Hypertarget{struct_ort_1_1_value_a0c36d72cdbef90aa1213a9d2553dfff2}\label{struct_ort_1_1_value_a0c36d72cdbef90aa1213a9d2553dfff2} 
{\footnotesize template$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{typename}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} $>$ }\\\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} {\bfseries Create\+Opaque} (\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{char}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{domain}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{char}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{type\+\_\+name}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} \&)
\begin{DoxyCompactList}\small\item\em Wraps Ort\+Api\+::\+Create\+Opaque\+Value. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{typename}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} $>$ }\\\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615}{Create\+Sparse\+Tensor}} (\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Memory\+Info}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{info}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} \texorpdfstring{$\ast$}{*}p\+\_\+data, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{dense\+\_\+shape}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&values\+\_\+shape)
\begin{DoxyCompactList}\small\item\em This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a69a8b95060c2a3a7c99178b5fc8bbd0d}{Create\+Sparse\+Tensor}} (\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Memory\+Info}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{info}}, void \texorpdfstring{$\ast$}{*}p\+\_\+data, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{dense\+\_\+shape}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&values\+\_\+shape, \mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}} type)
\begin{DoxyCompactList}\small\item\em Creates an Ort\+Value instance containing Sparse\+Tensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting Ort\+Value. This call constructs an instance that only contain a pointer to non-\/zero values. To fully populate the sparse tensor call Use$<$\+Format$>$\doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Indices()} API below to supply a sparse format specific indices. This API is not suitable for string data. Use \doxylink{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615}{Create\+Sparse\+Tensor()} with allocator specified so strings can be properly copied into the allocated buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{typename}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} $>$ }\\\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a5f05df6028c8e6dadaa930be29af221a}{Create\+Sparse\+Tensor}} (\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{allocator}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{dense\+\_\+shape}})
\begin{DoxyCompactList}\small\item\em This is a simple forwarding method to the below Create\+Sparse\+Tensor. This helps to specify data type enum in terms of C++ data type. Use Create\+Sparse\+Tensor$<$\+T$>$ \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{static}} \mbox{\hyperlink{struct_ort_1_1_value}{Value}} \mbox{\hyperlink{struct_ort_1_1_value_a7d998fdcad3c495fe5e7022a33e5690e}{Create\+Sparse\+Tensor}} (\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{allocator}}, \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{dense\+\_\+shape}}, \mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}} type)
\begin{DoxyCompactList}\small\item\em Creates an instance of Ort\+Value containing sparse tensor. The created instance has no data. The data must be supplied by on of the \doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Fill\+Sparse\+Tensor$<$\+Format$>$()} methods that take both non-\/zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create Ort\+Values that contain sparse tensors with all supported data types including strings. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{struct_ort_1_1detail_1_1_base}{Ort\+::detail\+::\+Base$<$ T $>$}}}
\begin{DoxyCompactItemize}
\item 
contained\+\_\+type \texorpdfstring{$\ast$}{*} {\bfseries p\+\_\+} \{\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Wrapper around \doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Value}. 

\doxysubsection{Member Function Documentation}
\Hypertarget{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615}\label{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615} 
\index{Ort::Value@{Ort::Value}!CreateSparseTensor@{CreateSparseTensor}}
\index{CreateSparseTensor@{CreateSparseTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateSparseTensor()}{CreateSparseTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{typename}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} $>$ \\
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Sparse\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Memory\+Info}} \texorpdfstring{$\ast$}{*}}]{info,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} \texorpdfstring{$\ast$}{*}}]{p\+\_\+data,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{dense\+\_\+shape,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{values\+\_\+shape }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & numeric datatype. This API is not suitable for strings.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em info} & Memory description where the user buffers reside (CPU vs GPU etc)\\
\hline
{\em p\+\_\+data} & pointer to the user supplied buffer, use nullptr for fully sparse tensors\\
\hline
{\em dense\+\_\+shape} & a would be dense shape of the tensor\\
\hline
{\em values\+\_\+shape} & non zero values shape. Use a single 0 shape for fully sparse tensors.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615_icgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a69a8b95060c2a3a7c99178b5fc8bbd0d}\label{struct_ort_1_1_value_a69a8b95060c2a3a7c99178b5fc8bbd0d} 
\index{Ort::Value@{Ort::Value}!CreateSparseTensor@{CreateSparseTensor}}
\index{CreateSparseTensor@{CreateSparseTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateSparseTensor()}{CreateSparseTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Sparse\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Ort\+Memory\+Info}} \texorpdfstring{$\ast$}{*}}]{info,  }\item[{void \texorpdfstring{$\ast$}{*}}]{p\+\_\+data,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{dense\+\_\+shape,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{values\+\_\+shape,  }\item[{\mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates an Ort\+Value instance containing Sparse\+Tensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting Ort\+Value. This call constructs an instance that only contain a pointer to non-\/zero values. To fully populate the sparse tensor call Use$<$\+Format$>$\doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Indices()} API below to supply a sparse format specific indices. This API is not suitable for string data. Use \doxylink{struct_ort_1_1_value_a7d1841b3f7caadcb33711701cef97615}{Create\+Sparse\+Tensor()} with allocator specified so strings can be properly copied into the allocated buffer. 


\begin{DoxyParams}{Parameters}
{\em info} & Memory description where the user buffers reside (CPU vs GPU etc)\\
\hline
{\em p\+\_\+data} & pointer to the user supplied buffer, use nullptr for fully sparse tensors\\
\hline
{\em dense\+\_\+shape} & a would be dense shape of the tensor\\
\hline
{\em values\+\_\+shape} & non zero values shape. Use a single 0 shape for fully sparse tensors.\\
\hline
{\em type} & data type\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxylink{struct_ort_1_1_value}{Ort\+::\+Value} instance containing Sparse\+Tensor
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a69a8b95060c2a3a7c99178b5fc8bbd0d_cgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a5f05df6028c8e6dadaa930be29af221a}\label{struct_ort_1_1_value_a5f05df6028c8e6dadaa930be29af221a} 
\index{Ort::Value@{Ort::Value}!CreateSparseTensor@{CreateSparseTensor}}
\index{CreateSparseTensor@{CreateSparseTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateSparseTensor()}{CreateSparseTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{typename}} \mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{T}} $>$ \\
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Sparse\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}}]{allocator,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{dense\+\_\+shape }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



This is a simple forwarding method to the below Create\+Sparse\+Tensor. This helps to specify data type enum in terms of C++ data type. Use Create\+Sparse\+Tensor$<$\+T$>$ 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & numeric data type only. String data enum must be specified explicitly.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em allocator} & allocator to use\\
\hline
{\em dense\+\_\+shape} & a would be dense shape of the tensor\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxylink{struct_ort_1_1_value}{Ort\+::\+Value}
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a5f05df6028c8e6dadaa930be29af221a_cgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a7d998fdcad3c495fe5e7022a33e5690e}\label{struct_ort_1_1_value_a7d998fdcad3c495fe5e7022a33e5690e} 
\index{Ort::Value@{Ort::Value}!CreateSparseTensor@{CreateSparseTensor}}
\index{CreateSparseTensor@{CreateSparseTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateSparseTensor()}{CreateSparseTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Sparse\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}}]{allocator,  }\item[{\mbox{\hyperlink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{const}} \mbox{\hyperlink{struct_ort_1_1detail_1_1_shape}{Shape}} \&}]{dense\+\_\+shape,  }\item[{\mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates an instance of Ort\+Value containing sparse tensor. The created instance has no data. The data must be supplied by on of the \doxylink{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}{Fill\+Sparse\+Tensor$<$\+Format$>$()} methods that take both non-\/zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create Ort\+Values that contain sparse tensors with all supported data types including strings. 


\begin{DoxyParams}{Parameters}
{\em allocator} & allocator to use. The allocator lifespan must eclipse that of the resulting Ort\+Value\\
\hline
{\em dense\+\_\+shape} & a would be dense shape of the tensor\\
\hline
{\em type} & data type\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an instance of \doxylink{struct_ort_1_1_value}{Ort\+::\+Value}
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a7d998fdcad3c495fe5e7022a33e5690e_cgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8}\label{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8} 
\index{Ort::Value@{Ort::Value}!CreateTensor@{CreateTensor}}
\index{CreateTensor@{CreateTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateTensor()}{CreateTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Tensor (\begin{DoxyParamCaption}\item[{const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}}]{info,  }\item[{T \texorpdfstring{$\ast$}{*}}]{p\+\_\+data,  }\item[{size\+\_\+t}]{p\+\_\+data\+\_\+element\+\_\+count,  }\item[{const int64\+\_\+t \texorpdfstring{$\ast$}{*}}]{shape,  }\item[{size\+\_\+t}]{shape\+\_\+len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates a tensor with a user supplied buffer. Wraps Ort\+Api\+::\+Create\+Tensor\+With\+Data\+As\+Ort\+Value. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The numeric datatype. This API is not suitable for strings. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em info} & Memory description of where the p\+\_\+data buffer resides (CPU vs GPU etc). \\
\hline
{\em p\+\_\+data} & Pointer to the data buffer. \\
\hline
{\em p\+\_\+data\+\_\+element\+\_\+count} & The number of elements in the data buffer. \\
\hline
{\em shape} & Pointer to the tensor shape dimensions. \\
\hline
{\em shape\+\_\+len} & The number of tensor shape dimensions. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=204pt]{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a23c32a59c2149a0faf54187af3cc5bb8_icgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a30dfeeee6f819d5c9df530cb164e4626}\label{struct_ort_1_1_value_a30dfeeee6f819d5c9df530cb164e4626} 
\index{Ort::Value@{Ort::Value}!CreateTensor@{CreateTensor}}
\index{CreateTensor@{CreateTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateTensor()}{CreateTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Tensor (\begin{DoxyParamCaption}\item[{const Ort\+Memory\+Info \texorpdfstring{$\ast$}{*}}]{info,  }\item[{void \texorpdfstring{$\ast$}{*}}]{p\+\_\+data,  }\item[{size\+\_\+t}]{p\+\_\+data\+\_\+byte\+\_\+count,  }\item[{const int64\+\_\+t \texorpdfstring{$\ast$}{*}}]{shape,  }\item[{size\+\_\+t}]{shape\+\_\+len,  }\item[{\mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates a tensor with a user supplied buffer. Wraps Ort\+Api\+::\+Create\+Tensor\+With\+Data\+As\+Ort\+Value. 


\begin{DoxyParams}{Parameters}
{\em info} & Memory description of where the p\+\_\+data buffer resides (CPU vs GPU etc). \\
\hline
{\em p\+\_\+data} & Pointer to the data buffer. \\
\hline
{\em p\+\_\+data\+\_\+byte\+\_\+count} & The number of bytes in the data buffer. \\
\hline
{\em shape} & Pointer to the tensor shape dimensions. \\
\hline
{\em shape\+\_\+len} & The number of tensor shape dimensions. \\
\hline
{\em type} & The data type. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a30dfeeee6f819d5c9df530cb164e4626_cgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_ae6214620fce2d87d9015ab44ebec0a11}\label{struct_ort_1_1_value_ae6214620fce2d87d9015ab44ebec0a11} 
\index{Ort::Value@{Ort::Value}!CreateTensor@{CreateTensor}}
\index{CreateTensor@{CreateTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateTensor()}{CreateTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}}]{allocator,  }\item[{const int64\+\_\+t \texorpdfstring{$\ast$}{*}}]{shape,  }\item[{size\+\_\+t}]{shape\+\_\+len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates a tensor using a supplied \doxylink{struct_ort_allocator}{Ort\+Allocator}. Wraps Ort\+Api\+::\+Create\+Tensor\+As\+Ort\+Value. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The numeric datatype. This API is not suitable for strings. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em allocator} & The allocator to use. \\
\hline
{\em shape} & Pointer to the tensor shape dimensions. \\
\hline
{\em shape\+\_\+len} & The number of tensor shape dimensions. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_ae6214620fce2d87d9015ab44ebec0a11_cgraph}
\end{center}
\end{figure}
\Hypertarget{struct_ort_1_1_value_a29ade31d524988ca8b461ca62b88c21a}\label{struct_ort_1_1_value_a29ade31d524988ca8b461ca62b88c21a} 
\index{Ort::Value@{Ort::Value}!CreateTensor@{CreateTensor}}
\index{CreateTensor@{CreateTensor}!Ort::Value@{Ort::Value}}
\doxysubsubsection{\texorpdfstring{CreateTensor()}{CreateTensor()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_ort_1_1_value}{Value}} Ort\+::\+Value\+::\+Create\+Tensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_ort_allocator}{Ort\+Allocator}} \texorpdfstring{$\ast$}{*}}]{allocator,  }\item[{const int64\+\_\+t \texorpdfstring{$\ast$}{*}}]{shape,  }\item[{size\+\_\+t}]{shape\+\_\+len,  }\item[{\mbox{\hyperlink{group___global_gaec63cdda46c29b8183997f38930ce38e}{ONNXTensor\+Element\+Data\+Type}}}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Creates a tensor using a supplied \doxylink{struct_ort_allocator}{Ort\+Allocator}. Wraps Ort\+Api\+::\+Create\+Tensor\+As\+Ort\+Value. 


\begin{DoxyParams}{Parameters}
{\em allocator} & The allocator to use. \\
\hline
{\em shape} & Pointer to the tensor shape dimensions. \\
\hline
{\em shape\+\_\+len} & The number of tensor shape dimensions. \\
\hline
{\em type} & The data type. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{struct_ort_1_1_value_a29ade31d524988ca8b461ca62b88c21a_cgraph}
\end{center}
\end{figure}


The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/m5963/\+Documents/\+Git\+Hub/\+Anim\+Host/\+Anim\+Host/anim\+Host\+\_\+\+Plugins/\+Basic\+Onnx\+Plugin/onnxruntime/include/onnxruntime\+\_\+cxx\+\_\+api.\+h\item 
C\+:/\+Users/m5963/\+Documents/\+Git\+Hub/\+Anim\+Host/\+Anim\+Host/anim\+Host\+\_\+\+Plugins/\+Basic\+Onnx\+Plugin/onnxruntime/include/onnxruntime\+\_\+cxx\+\_\+inline.\+h\end{DoxyCompactItemize}
